const Scene = require("telegraf/scenes/base");
const DeliveryChatId = process.env.chatDeliverId;
const buttons = require("./buttons/buttons");
const product = require("./product/product");
const delivery = require("./delivery/delivery");
const data = require("../DAO/classesQuery").ProductsQuery;
const OrderProcessing = require("./middleWare/OrderProcessing");
const EventEmitter = require("events");
const onChangeEmitter = new EventEmitter();
const sendOrdersToDeliveryChat = require("./middleWare/sendOrdersToDeliveryChat");

onChangeEmitter.on("changeStatus", sendOrdersToDeliveryChat);

class sceneGenerator {
  sceneProductModels() {
    const productModels = new Scene("productModels");
    productModels.enter(async (ctx) => {
      const greetings = (num) => {
        return num == 1 ? "–ü—Ä–∏–≤–µ—Ç! –≤—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å üëá" : "–í—ã–±–µ—Ä–∏—Ç–µ  –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –º–æ–¥–µ–ª—å üëá";
      };
      //response return all products  list configuration
      const response = await product.getModels();
      ctx.session.products = response;
      await ctx.reply(
        `${ctx.message.from.first_name},${greetings(ctx.session.positionCounter)}`,
        buttons.buttonsGenerator(response)
      );
    });
    productModels.hears("ownSecret", async (ctx) => {
      const response = await data.checkPaymentStatus();
      let status = response[0].status;
      status = !status;
      await data.paymentStatusChange({ status });
      onChangeEmitter.emit("changeStatus", { ctx, DeliveryChatId });
      ctx.reply(`status change to:${status}`);
    });
    productModels.on("text", async (ctx) => {
      // checking, user has chosen one of the proposed options or not
      const selectedButtonText = ctx.message.text;
      const result = ctx.session.products.filter((obj) => obj.name == selectedButtonText);
      // if the user entered something else, result will be an empty []
      if (!result.length) {
        ctx.reply("–æ–ø–µ—á–∞—Ç–∫–∞ üòú");
        ctx.scene.reenter();
      } else {
        ctx.session.order += `${ctx.session.positionCounter} : ${selectedButtonText}`;
        ++ctx.session.positionCounter;
        ctx.session.productId = result[0].model_id;
        ctx.session.totalPrice += +result[0].price;
        ctx.scene.enter("productTastes");
      }
    });
    productModels.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    productModels.on("message", async (ctx) => {
      await ctx.reply("‚õîÔ∏è –í—ã –Ω–µ –≤—ã–±—Ä–∞–ª–∏ –º–æ–¥–µ–ª—å");
      ctx.scene.reenter();
    });
    return productModels;
  }
  sceneProductTastes() {
    const productTastes = new Scene("productTastes");
    productTastes.enter(async (ctx) => {
      //response receive all current products tastes list
      const response = await product.getTastes(ctx.session.productId);
      ctx.session.selectedTaste = response;
      await ctx.reply(`–¢–µ–ø–µ—Ä—å –≤—ã–±–µ—Ä–∏—Ç–µ –ª—é–±–æ–π –≤–∫—É—Å üëá`, buttons.buttonsGenerator(response));
    });
    productTastes.on("text", async (ctx) => {
      const selectedButtonText = ctx.message.text;
      const result = ctx.session.selectedTaste.filter(
        (obj) => obj.taste_name == selectedButtonText
      );
      if (ctx.session.selectedTaste[0].taste_name == selectedButtonText) {
        await ctx.reply("üî• Ok –≤—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –∑–∞–Ω–æ–≤–æ üî•");
        ctx.session.order = "";
        ctx.session.positionCounter = 1;
        ctx.session.totalPrice = 0;
        ctx.scene.enter("productModels");
      } else if (!result.length) {
        await ctx.reply("–û–ø–µ—á–∞—Ç–∫–∞ üòú");
        ctx.scene.reenter();
      } else {
        ctx.session.order += `,–≤–∫—É—Å: ${result[0].taste_name}`;
        ctx.scene.enter("productsAdd");
      }
    });
    productTastes.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    productTastes.on("message", async (ctx) => {
      await ctx.reply("–õ—É—á—à–µ –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∫—É—Å ü•∏");
      ctx.scene.reenter();
    });
    return productTastes;
  }
  sceneAdditionalProducts() {
    const productsAdd = new Scene("productsAdd");
    productsAdd.enter(async (ctx) => {
      await ctx.reply(
        `–•–æ—Ç–∏—Ç–µ –≤—ã–±—Ä–∞—Ç—å –µ—â—ë –æ–¥–∏–Ω –≤–µ–π–ø —Å –¥—Ä—É–≥–∏–º –≤–∫—É—Å–æ–º ?`,
        buttons.staticButtonsDecision
      );
    });
    productsAdd.on("text", async (ctx) => {
      const selectedButtonText = ctx.message.text;
      if (selectedButtonText == "–¥–∞") {
        ctx.session.order += `;
        `;
        ctx.scene.enter("productModels");
      } else if (selectedButtonText == "–Ω–µ—Ç") {
        ctx.scene.enter("deliveryData");
      } else {
        await ctx.reply("–û–ø–µ—á–∞—Ç–∫–∞,–ø–æ–≤—Ç–æ—Ä–∏—Ç–µ ‚õîÔ∏è");
        ctx.scene.reenter();
      }
    });
    productsAdd.on("message", async (ctx) => {
      await ctx.reply("–í—ã–±–µ—Ä–∏—Ç–µ –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ ü•∏");
      ctx.scene.reenter();
    });
    productsAdd.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    return productsAdd;
  }
  sceneDeliveryData() {
    const deliveryData = new Scene("deliveryData");
    deliveryData.enter(
      async (ctx) =>
        await ctx.reply(
          "üëâ –í–≤–µ–¥–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω –∏ –∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏.üì¶ –î–ª—è –¥–æ—Å—Ç–∞–≤–∫–∏ –ø–æ—á—Ç–æ–π:üëâ —Ç–µ–ª–µ—Ñ–æ–Ω, –∞–¥—Ä–µ—Å, –∏–Ω–¥–µ–∫—Å, —Ñ–∏–æ üëÄ",
          buttons.staticButtonsHide
        )
    );
    deliveryData.on("text", async (ctx) => {
      const usersTextInput = ctx.message.text;
      // phoneCheck function checking part of phone number
      if (usersTextInput.length > 14 && delivery.phoneNumbersCheck(usersTextInput)) {
        ctx.session.order += `.
         —Ç–µ–ª/–∞–¥—Ä–µ—Å –¥–æ—Å—Ç–∞–≤–∫–∏ : ${usersTextInput}`;
        ctx.scene.enter("productDelivery");
      } else {
        await ctx.reply(
          "–í–≤–µ–¥–∏—Ç–µ —Å–≤–æ–π —Ç–µ–ª–µ—Ñ–æ–Ω –∏ –∞–¥—Ä–µ—Å –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤ —Ç–∞–∫–æ–º –∫–ª—é—á–µ. –ü—Ä–∏–º–µ—Ä: +375291234567 –≥.–ú–∏–Ω—Å–∫  –ù–µ–º–∏–≥–∞ 1. ( –ü–æ—á—Ç–æ–≤–∞—è –ø–æ—Å—ã–ª–∫–∞: +375291234567 –≥.–ë—Ä–µ—Å—Ç, –∏–Ω–¥–µ–∫—Å 224001, —É–ª.–ü–æ–±–µ–¥—ã 10, –ö–æ—Ç –ò–≤–∞–Ω –ò–≤–∞–Ω—ã—á"
        ),
          ctx.scene.reenter();
      }
    });
    deliveryData.on("message", async (ctx) => {
      await ctx.reply("–ù—É–∂–µ–Ω —Ç–æ–ª—å–∫–æ —Ç–µ–ª–µ—Ñ–æ–Ω –∏ –∞–¥—Ä–µ—Å üòú");
      ctx.scene.reenter();
    });
    deliveryData.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    return deliveryData;
  }
  sceneDeliveryMethods() {
    const productDelivery = new Scene("productDelivery");
    productDelivery.enter(async (ctx) => {
      //response return all productDelivery method list
      const response = await delivery.getDeliveryMethods(ctx.session.positionCounter);
      ctx.session.deliveryMethod = response;
      await ctx.reply(
        "–í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –¥–æ—Å—Ç–∞–≤–∫–∏ —Å 10:00 –¥–æ 20:00 üëá",
        buttons.buttonsGenerator(response)
      );
    });
    productDelivery.on("text", async (ctx) => {
      const selectedButtonText = ctx.message.text;
      const result = ctx.session.deliveryMethod.filter((obj) => obj.name == selectedButtonText);
      if (!result.length) {
        await ctx.reply("–û–ø–µ—á–∞—Ç–∫–∞, –ø—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Çüëá");
        ctx.scene.reenter();
      } else {
        ctx.session.order += `.
        –î–æ—Å—Ç–∞–≤–∫–∞ : ${result[0].name} `;
        ctx.session.totalPrice += +result[0].price;
        ctx.scene.enter("commentDecision");
      }
    });
    productDelivery.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    productDelivery.on("message", async (ctx) => {
      await ctx.reply("–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –¥–æ—Å—Ç–∞–≤–∫–∏ üöï");
      ctx.scene.reenter();
    });
    return productDelivery;
  }
  sceneCommentAddDecision() {
    const commentDecision = new Scene("commentDecision");
    commentDecision.enter(
      async (ctx) =>
        await ctx.reply("–•–æ—Ç–∏—Ç–µ –æ—Å—Ç–∞–≤–∏—Ç—å –ø–æ–∂–µ–ª–∞–Ω–∏–µ –∫ –∑–∞–∫–∞–∑—É?", buttons.staticButtonsDecision)
    );
    commentDecision.on("text", async (ctx) => {
      const selectedButtonText = ctx.message.text;

      if (selectedButtonText == "–¥–∞") {
        ctx.scene.enter("userComments");
      } else if (selectedButtonText == "–Ω–µ—Ç") {
        ctx.session.order += `.
        –ü–æ–∂–µ–ª–∞–Ω–∏—è:–Ω–µ—Ç—É.`;
        ctx.scene.enter("checkingData");
      } else {
        await ctx.reply("–û–ø–µ—á–∞—Ç–∫–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Çüëá");
        ctx.scene.reenter();
      }
    });
    commentDecision.on("message", async (ctx) => {
      ctx.reply("–ü—Ä–æ—Å—Ç–æ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω—É–∂–Ω—É—é –∫–Ω–æ–ø–∫—Éüëá");
      ctx.scene.reenter();
    });
    commentDecision.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    return commentDecision;
  }
  sceneUserComments() {
    const userComments = new Scene("userComments");
    userComments.enter(async (ctx) => {
      await ctx.reply("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π üëá", buttons.staticButtonsHide);
    });
    userComments.on("text", async (ctx) => {
      const userInputText = ctx.message.text;
      ctx.session.order += `.
         –ü–æ–∂–µ–ª–∞–Ω–∏–µ : ${userInputText}`;
      await ctx.reply("–•–æ—Ä–æ—à–æ‚úÖ");
      ctx.scene.enter("checkingData");
    });
    userComments.on("message", async (ctx) => {
      await ctx.reply("–í–≤–µ–¥–∏—Ç–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π, —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç–∞üí°");
      ctx.scene.reenter();
    });
    return userComments;
  }
  sceneCheckingOrder() {
    const checkingData = new Scene("checkingData");
    checkingData.enter(async (ctx) => {
      await ctx.reply(
        `–ò—Ç–∞–∫ ${ctx.session.order}.
        –°—É–º–º–∞ –∑–∞–∫–∞–∑–∞ :${ctx.session.totalPrice} P—É–±.
         –ü—Ä–∞–≤–∏–ª—å–Ω–æ ? ? ?`,
        buttons.staticButtonsConfirmation
      );
    });
    checkingData.on("text", async (ctx) => {
      let ordersCount = await data.getDeliveryCount(); //count return  last order  number from db
      const selectedButtonText = ctx.message.text;
      if (selectedButtonText == "–í—Å–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ üòä") {
        const response = await data.checkPaymentStatus();
        const paymentStatus = response[0].status;

        const userOrders = `üìü  –ó–∞–∫–∞–∑ ‚Ññ ${ordersCount[0].count}.
          –ò–º—è :${ctx.message.from.first_name}
        ${ctx.session.order}.
        –°—É–º–º–∞ –∑–∞–∫–∞–∑–∞ :${ctx.session.totalPrice} —Ä—É–±`;

        await OrderProcessing({
          paymentStatus,
          ctx,
          userOrders,
          DeliveryChatId,
          ordersCount,
        });

        await ctx.reply(
          `üìü –í–∞—à –∑–∞–∫–∞–∑ ‚Ññ ${ordersCount[0].count} –æ—Ñ–æ—Ä–º–ª–µ–Ω üëç . 
        –°–ø–∞—Å–∏–±–æ –∑–∞ –≤—ã–±–æ—Ä Wlab!
          –î–ª—è –Ω–æ–≤–æ–≥–æ –∑–∞–∫–∞–∑–∞, –∂–º–∏—Ç–µ üëâ /start`
        );
        await data.updateDeliveryCount(++ordersCount[0].count);
        ctx.scene.leave();
      } else if (selectedButtonText == "–æ–π, –æ—Ç–º–µ–Ω–∞ ü§≠") {
        await ctx.reply("Ok –≤—Ç–æ—Ä–∞—è –ø–æ–ø—ã—Ç–∫–∞üëá");
        ctx.session.order = "";
        ctx.session.positionCounter = 1;
        ctx.session.totalPrice = 0;
        ctx.scene.enter("productModels");
      }
    });
    checkingData.on("message", async (ctx) => {
      await ctx.reply("–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –Ω—É–∂–Ω—É—é –∫–Ω–æ–ø–∫—Éüëá");
      ctx.scene.reenter();
    });
    checkingData.on("sticker", (ctx) => {
      ctx.reply("üëç");
      ctx.scene.reenter();
    });
    return checkingData;
  }
}
module.exports = sceneGenerator;
